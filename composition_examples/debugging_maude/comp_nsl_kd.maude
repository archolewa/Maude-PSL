---Only for debugging.
load psl.maude
select COMP-TRANSLATION-TO-MAUDE-NPA .
set print attribute off .

rew 
[comp(1, 2) |-> 
    nsl-A ;* kd-B : A |-> B,  B |-> A, K |-> h(n(A, r) ; NB) .[3]
    nsl-B ;* kd-A : A |-> B, B |-> A1, K |-> h(NA1 ; n(B, r1)) .[3]
    nsl-A ;* kd-A : A |-> A,  B |-> B, K |-> h(n(A, r) ; NB) .[3]     
    nsl-B ;* kd-B : A |-> A1, B |-> B, K |-> h(NA1 ; n(B, r1)) .[3]
]
[mt]
---Only here for purposes of debugging. 
---Note: This should be added by Python if there are no attacks.
[$emptyAttackData] 
translate(1,
[$noDefs]
[mt]
[empty]
Specification
{
Protocol
{
    In(nsl-A) = A, B .[1]
    In(nsl-B) = B .[1]


    1 . nsl-A -> nsl-B : pk(B, n(A, r:Fresh) ; A) |- 
                         pk(B, NA1           ; A1) .[1]

    2 . nsl-B -> nsl-A : pk(A1, NA1           ; n(B, r1:Fresh) ; B) |-    
                         pk(A , n(A, r:Fresh) ; NB             ; B) .[1] 

    3 . nsl-A -> nsl-B : pk(B, NB) |- 
                         pk(B, n(B, r1:Fresh)) .[1]                    


    Out(nsl-A) = A, B, n(A, r:Fresh), NB, h(n(A, r:Fresh) ; NB) .[1]
    Out(nsl-B) = A1, B, NA1, n(B, r1:Fresh), h(NA1 ; n(B, r1:Fresh)) .[1]
}
Intruder
{

    => C .[1]
    X, Y <=> X ; Y .[1]
    X =>  sk(i, X) .[1]
    K, X => pk(K, X) .[1]
}

Attacks
{
    0 .
    {
        nsl-B executes protocol .[1]
        Intruder learns n(B, r1:Fresh) .[1]
        Subst(nsl-B) = B |-> b, A1 |-> a .[1]
    }
}
}
)
translate(2, 
[$noDefs]
[mt]
[empty]

Specification
{
Protocol
{
    In(kd-A) = A, B, K .[2]
    In(kd-B) = A, B, K .[2]

    1 . kd-A -> kd-B : e(K, skey(A, r)) |- 
                       e(K, SK)         .[2]

    2 . kd-B -> kd-A : e(K, SK         ; n(B, r1)) |-
                       e(K, skey(A, r) ; NB)       .[2]

    3 . kd-A -> kd-B : e(K, NB)       |- 
                       e(K, n(B, r1)) .[2]

    Out(kd-A) = K, skey(A, r), NB .[2]
    Out(kd-B) = A, B, K, SK, n(B, r1) .[2]
}
Intruder
{
         => C, n(i, r), skey(i, r) .[2]
    K, X => e(K, X), d(K, X) .[2]
    X, Y <=> X ; Y .[2]
}
Attacks
{
    0 .
    {
        kd-B executes protocol .[2]
        Subst(kd-B) = A |-> a, B |-> b .[2]
    }
}
}
) .
q
Specification{
Protocol{
		
In(kd-A)= K,A,B .[2] .

In(kd-B)= K,A,B .[2]

1 . kd-A -> kd-B : e(K,skey(A, r)) |- e(K,SK) .[2] .
q
2 . kd-B -> kd-A : e(K,SK ; n(B, r1)) |- e(K,skey(A, r) ; NB) .[2]

3 . kd-A -> kd-B : e(K,NB) |- e(K,n(B, r1)) .[2]

Out(kd-A)= K,NB,skey(A, r) .[2]
Out(kd-B)= K,SK,A,B,n(B, r1) .[2]
}
Intruder{
		
emptyMsgSet => C .[2]

emptyMsgSet => skey(i, r) .[2]

emptyMsgSet => n(i, r) .[2]

K,X => e(K,X),d(K,X) .[2]

X,Y => X ; Y .[2]

X ; Y => X .[2]
X ; Y => Y .[2]
	}
Attacks{
		0 .{kd-B executes protocol .[2] Subst(kd-B)= A |-> a,B |-> b .[
    2]}
	}} 
.
