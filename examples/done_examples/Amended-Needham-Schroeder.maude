fmod PROTOCOL-EXAMPLE-SYMBOLS is protecting DEFINITION-PROTOCOL-RULES .
sorts SName  Name  Key  Nonce  Masterkey  Sessionkey .
subsorts Masterkey  Sessionkey < Key .
subsorts SName < Name .
subsorts Name < Public .
op n : Name  Fresh -> Nonce [ frozen ] .
op a : -> Name .
op b : -> Name .
op i : -> Name .
op s : -> SName .
op mkey : Name  Name -> Masterkey [ frozen ] .
op seskey : Name  Name  Nonce -> Sessionkey [ frozen ] .
op e : Key  Msg -> Msg [ frozen ] .
op d : Key  Msg -> Msg [ frozen ] .
op dec : Nonce -> Msg [ frozen ] .
op null : -> Msg .
op _;_ : Msg  Msg -> Msg [ gather  (  e  E  )  frozen ] .
op t : -> Msg .
subsorts SName  Name  Key  Nonce  Masterkey  Sessionkey < Msg .
op _$;_ : Msg Msg -> Msg [ctor gather(e E) frozen].
endfm

fmod PROTOCOL-EXAMPLE-ALGEBRAIC is protecting PROTOCOL-EXAMPLE-SYMBOLS .
eq d(K:Key, e(K:Key, Z:Msg)) = Z:Msg [ variant ] .
eq e(K:Key, d(K:Key, Z:Msg)) = Z:Msg [ variant ] .
endfm
fmod PROTOCOL-SPECIFICATION is protecting PROTOCOL-EXAMPLE-SYMBOLS .
protecting DEFINITION-PROTOCOL-RULES .
protecting DEFINITION-CONSTRAINTS-INPUT .
eq STRANDS-DOLEVYAO = 
:: nil ::
[ nil | 
   +(s), nil]  & 
:: nil ::
[ nil | 
   +(A:Name), nil]  & 
:: nil ::
[ nil | 
   +(mkey(i, s)), nil]  & 
:: nil ::
[ nil | 
   +(mkey(i, A:Name)), nil]  & 
:: nil ::
[ nil | 
   +(mkey(s, i)), nil]  & 
:: nil ::
[ nil | 
   +(mkey(A:Name, i)), nil]  & 
:: nil ::
[ nil | 
   -(M1:Msg), 
   -(M:Msg), 
   +(M:Msg ; M1:Msg), nil]  & 
:: nil ::
[ nil | 
   -(N:Nonce), 
   +(dec(N:Nonce)), nil]  & 
:: nil ::
[ nil | 
   -(K:Key), 
   -(M:Msg), 
   +(e(K:Key, M:Msg)), nil]  & 
:: nil ::
[ nil | 
   -(K:Key), 
   -(M:Msg), 
   +(d(K:Key, M:Msg)), nil]  & 
:: nil ::
[ nil | 
   -(dec(N:Nonce)), 
   +(N:Nonce), nil]  & 
:: nil ::
[ nil | 
   -(M:Msg ; M1:Msg), 
   +(M:Msg), nil]  & 
:: nil ::
[ nil | 
   -(M:Msg ; M1:Msg), 
   +(M1:Msg), nil]  & 
:: r:Fresh ::
[ nil | 
   +(n(i, r:Fresh)), nil] [nonexec].
eq STRANDS-PROTOCOL = 
:: r:Fresh ::
[ nil | 
   +(ANAME:Name), 
   -(M1:Msg), 
   +(ANAME:Name ; BNAME:Name ; n(ANAME:Name, r:Fresh) ; M1:Msg), 
   -(e(mkey(ANAME:Name, SNAME:Name), n(ANAME:Name, r:Fresh) ; BNAME:Name ; KA:Key ; M2:Msg)), 
   +(M2:Msg), 
   -(e(KA:Key, NB:Nonce)), 
   +(e(KA:Key, dec(NB:Nonce))), nil]  & 
:: r1:Fresh ::
[ nil | 
   -(A2NAME:Name ; B2NAME:Name ; NA2:Nonce ; e(mkey(B2NAME:Name, SNAME:Name), A2NAME:Name ; NB2:Nonce)), 
   +(e(mkey(A2NAME:Name, SNAME:Name), NA2:Nonce ; B2NAME:Name ; seskey(A2NAME:Name, B2NAME:Name, n(SNAME:Name, r1:Fresh)) ; e(mkey(B2NAME:Name, SNAME:Name), seskey(A2NAME:Name, B2NAME:Name, n(SNAME:Name, r1:Fresh)) ; NB2:Nonce ; A2NAME:Name))), nil]  & 
:: r2:Fresh,r0:Fresh ::
[ nil | 
   -(A1NAME:Name), 
   +(e(mkey(BNAME:Name, SNAME:Name), A1NAME:Name ; n(BNAME:Name, r0:Fresh))), 
   -(e(mkey(BNAME:Name, SNAME:Name), KB:Key ; n(BNAME:Name, r0:Fresh) ; A1NAME:Name)), 
   +(e(KB:Key, n(BNAME:Name, r2:Fresh))), 
   -(e(KB:Key, dec(n(BNAME:Name, r2:Fresh)))), nil] [nonexec].
var LIST : SMsgList-R . var K : IntruderKnowledge . var S : StrandSet . eq ATTACK-STATE(0)= 
:: r2:Fresh,r0:Fresh ::
[ nil, 
   -(a), 
   +(e(mkey(b, s), a ; n(b, r0:Fresh))), 
   -(e(mkey(b, s), KB:Key ; n(b, r0:Fresh) ; a)), 
   +(e(KB:Key, n(b, r2:Fresh))), 
   -(e(KB:Key, dec(n(b, r2:Fresh)))) | nil] 
|| empty
|| 
nil
|| 
nil
|| 
nil[nonexec].
 endfm
select MAUDE-NPA .