/*
    A simple protocol that demonstrates Diffie-Helman public and secret key encryption
    with keys generated using exponents, and the fact that 
    g^(a * b) = (g^a)^b.
*/
spec DIFFIE-HELMAN is
Theory
  types Name Nonce NeNonceSet Gen Exp Key GenvExp Secret .
  subtype Gen Exp < GenvExp .
  subtype Exp < Key .
  subtype Name < Public . // This is quite relevant and necessary
  subtype Gen < Public . // This is quite relevant and necessary

  op sec : Name Fresh -> Secret .

  op n : Name Fresh -> Nonce .

  ops a b i : -> Name .

  op e : Key Msg -> Msg .
  op d : Key Msg -> Msg .

  op exp : GenvExp NeNonceSet -> Exp .

  op g : -> Gen .

  subtype Nonce < NeNonceSet .
  op _*_ : NeNonceSet NeNonceSet -> NeNonceSet [assoc comm] .

  op _;_ : Msg Msg -> Msg [gather (e E)] .

  eq exp(exp(W:Gen,Y:NeNonceSet),Z:NeNonceSet) = exp(W:Gen, Y:NeNonceSet * Z:NeNonceSet) .
  eq e(K:Key,d(K:Key,M:Msg)) = M:Msg .
  eq d(K:Key,e(K:Key,M:Msg)) = M:Msg .

Protocol
    vars A B : Name .
    vars r r' r1 : Fresh .
    vars XEA XEB : Exp .
    var S : Secret .

    In(A) = A, B .
    Def(A) = na := n(A, r), secret := sec(A, r') .
    /*
    Try using these definitions to make sure they work properly.
        Def(A) = pa := n(A, r1), 
                  s := sec(A, r'), 
               g^pa := exp(g, pa), 
               xea^pa := exp(XEA, pa) .
        Def(B) = g^pb := exp(g, pb), 
                   pb := n(B, r2), 
               xeb^pb := exp(XEB, pb) .
   */

    In(B) = B .
    Def(B) = nb := n(B, r1) .

    1 . A -> B : A  ; B ; exp(g, na)      
              |- A1 ; B ; XEB .
    2 . B -> A : A1 ; B ; exp(g, nb)      
              |- A  ; B ; XEA .
    3 . A -> B : e(exp(XEA, na), secret)     
              |- e(exp(XEB, nb), S) .

    Out(A) = na, exp(g, na), XEB, secret .
    Out(B) = nb, exp(g, nb), XEA, S .

Intruder
    vars A : Name .
    var K : Key .
    vars M M1 M2 : Msg .
    vars NS1 NS2 : NeNonceSet .
    var GE : GenvExp .
    var r  : Fresh .
    => n(i, r), g, A .
    M1 ; M2 <=> M1, M2 .
    K, M => e(K, M), d(K, M) .
    NS1, NS2  => NS1 * NS2 .
    GE, NS1 => exp(GE, NS1) .

Attacks
    /*
        Authentication attack meant to make sure the protocol is implemented
        properly. If this "attack" does not find an initial state, then this
        protocol was implemented incorrectly.
    */
    vars A B : Name
    var S : Secret .
    0 .
        B executes protocol .
        Subst(B) = A1 |-> a, B |-> b, S |-> sec(a, r') .
        without:
            Subst(A) = A |-> a, B |-> b .
            A executes protocol .
    1 .
        B executes protocol .
        Subst(B) = A1 |-> a, B |-> b, S |-> sec(a, r') .
        Intruder learns sec(a, r') .
            
    /*
        Note: Attack 2 in the dh.maude example is identical to attack 1 above,
        except that it includes never patterns for avoiding unreachable states.
        This language isn't expressive enough for that kind of optimization. 
        However, that's an optimization that should probably be performed at the
        lower Maude-NPA strand level, because optimizations run the risk of losing
        completenes, in which case you should only perform them if you *really*
        know what you're doing.
    */
ends
