fmod PROTOCOL-EXAMPLE-SYMBOLS is protecting DEFINITION-PROTOCOL-RULES . --- -1
    sorts Name Nonce Key .
    subsort Name < Key .
    subsort Name < Public .
    subsorts Name Nonce Key < Msg .

    ops pk sk : Key Msg -> Msg [frozen] .

    op n : Name Fresh -> Nonce [frozen] .

    ops a b i : -> Name . --- Alice Bob Intruder

    op _;_ : Msg Msg -> Msg [gather frozen (e E)] .

    op h : Msg -> Key [frozen] .

    var Z : Msg .
    var K : Key .

    ops a b i : -> Name .

    op 0 : -> Msg .
    op n : Name Fresh -> Nonce .

    op _*_ : Msg Msg -> Msg [assoc comm frozen] .

    ops a b i : -> Name .

    op 0 : -> Msg .
    op n : Name Fresh -> Nonce [frozen] .

    op _*_ : Msg Msg -> Msg [assoc comm frozen] .

    ---------------Automatically generated and added by Python------------
    ops nsl-A nsl-B : -> Role .

    ops db-A db-B : -> Role .

    ---Used for building the message for the synchronization message.
    op _$;_ : Msg Msg -> Msg [gather(E e) frozen] .
    ----------End Automatically generated and added by Python-------------------


endfm

fmod PROTOCOL-EXAMPLE-ALGEBRAIC is protecting PROTOCOL-EXAMPLE-SYMBOLS .

    var Z : Msg .
    var K : Key .

    ---Encryption/Decryption Cancellation
    eq pk(K,sk(K,Z)) = Z [variant] .
    eq sk(K,pk(K,Z)) = Z [variant] .

    vars X Y : Msg .
    eq X * X = 0 [variant] .
    eq X * 0 = X [variant] .
    eq X * X * Y = Y [variant] .

endfm


---Module automatically generated.
fmod PROTOCOL-SPECIFICATION is protecting PROTOCOL-EXAMPLE-SYMBOLS .
protecting DEFINITION-PROTOCOL-RULES .
protecting DEFINITION-CONSTRAINTS-INPUT .
vars A B A1 : Name .
vars NA1 NB : Nonce .
var C    : Name .
vars X Y : Msg .
var K    : Key .
var NA : Nonce .
var NO : Nonce .
eq STRANDS-DOLEVYAO = 
:: nil ::
[ nil | 
   +(C), nil]  & 
:: nil ::
[ nil | 
   -(X), 
   +(sk(i, X)), nil]  & 
:: nil ::
[ nil | 
   -(X), 
   -(K), 
   +(pk(K, X)), nil]  & 
:: nil ::
[ nil | 
   -(Y), 
   -(X), 
   +(X ; Y), nil]  & 
:: nil ::
[ nil | 
   -(Y), 
   -(X), 
   +(X * Y), nil]  & 
:: nil ::
[ nil | 
   -(X ; Y), 
   +(X), nil]  & 
:: nil ::
[ nil | 
   -(X ; Y), 
   +(Y), nil]  & 
:: r:Fresh ::
[ nil | 
   +(n(i, r:Fresh)), nil] [nonexec].
eq STRANDS-PROTOCOL = 
:: nil ::
[ nil | 
   {nsl-A -> db-B ;; 1-1 ;; A $; B $; NO}, 
   -(NA), 
   +(NA * NO), nil]  & 
:: r:Fresh ::
[ nil | 
   +(pk(B, n(A, r:Fresh) ; A)), 
   -(pk(A, n(A, r:Fresh) ; NB ; B)), 
   +(pk(B, NB)), 
   {nsl-A -> db-B ;; 1-1 ;; B $; A $; n(A, r:Fresh)}, nil]  & 
:: r:Fresh ::
[ nil | 
   {nsl-B -> db-A ;; 1-1 ;; A $; B $; NO}, 
   +(n(A, r:Fresh)), 
   -(NO * n(A, r:Fresh)), nil]  & 
:: r1:Fresh ::
[ nil | 
   -(pk(B, NA1 ; A1)), 
   +(pk(A1, NA1 ; n(B, r1:Fresh) ; B)), 
   -(pk(B, n(B, r1:Fresh))), 
   {nsl-B -> db-A ;; 1-1 ;; B $; A1 $; NA1}, nil] [nonexec]
. 

endfm
