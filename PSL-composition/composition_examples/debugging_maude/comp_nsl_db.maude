load psl.maude
select COMP-TRANSLATION-TO-MAUDE-NPA .
rew [comp(1, 2) |-> 
    nsl-A ;1 db-B : A |-> B,  B |-> A, NO |-> n(A, r:Fresh) .[3]
    nsl-B ;1 db-A : B |-> A1, A |-> B, NO |-> NA1 .[3]
]
[mt]
---Only here for purposes of debugging. 
---Note: This should be added by Python if there are no attacks.
[$emptyAttackData] 
translate(1,
[$noDefs]
[mt]
[empty]
Specification
{
Protocol
{
    In(nsl-A) = A, B .[1]
    In(nsl-B) = B .[1]


    1 . nsl-A -> nsl-B : pk(B, n(A, r:Fresh) ; A) |- 
                         pk(B, NA1           ; A1) .[1]

    2 . nsl-B -> nsl-A : pk(A1, NA1           ; n(B, r1:Fresh) ; B) |-    
                         pk(A , n(A, r:Fresh) ; NB             ; B) .[1] 

    3 . nsl-A -> nsl-B : pk(B, NB) |- 
                         pk(B, n(B, r1:Fresh)) .[1]                    


    Out(nsl-A) = A, B, n(A, r:Fresh), NB, h(n(A, r:Fresh) ; NB) .[1]
    Out(nsl-B) = A1, B, NA1, n(B, r1:Fresh), h(NA1 ; n(B, r1:Fresh)) .[1]
}
Intruder
{

    => C .[1]
    X, Y <=> X ; Y .[1]
    X =>  sk(i, X) .[1]
    K, X => pk(K, X) .[1]
}

Attacks
{
    0 .
    {
        nsl-B executes protocol .[1]
        Intruder learns n(B, r1:Fresh) .[1]
        Subst(nsl-B) = B |-> b, A1 |-> a .[1]
    }
}
}
)
translate(2, 
[$noDefs]
[mt]
[empty]

Specification
{
Protocol
{
    In(db-A) = A, B, NO .[2]
    In(db-B) = A, B, NO .[2]

    1 . db-A -> db-B : n(A, r:Fresh)  |- NA .[2]
    2 . db-B -> db-A : NO * NA        |- NO * n(A, r:Fresh) .[2]

    Out(db-A) = n(A, r:Fresh), NO * n(A, r:Fresh) .[2]
    Out(db-B) = NA, NO * NA .[2]
}
Intruder
{
         => C, n(i, r:Fresh) .[2]
    X, Y => X * Y .[2]
}
Attacks
{
    0 .
    {
        db-B executes protocol .[2]
        Subst(db-B) = A |-> a, B |-> b .[2]
    }
}
}
) .
